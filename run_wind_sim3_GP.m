%% INFO
% sizes of matrices - often confusing
% check inputs and outputs from wind_sim3

global g
global Cd0 S AR e m Nmax Nmin CL_max dphi_dt_max GR_approx

g		= 9.81;			% Acceleration due to gravity

% --- Aircraft parameters --- %
Cd0		= 0.012;		% Parasitic drag coefficient
S		= 0.95677;		% Wing reference area
AR		= 19.54;		% Wing aspect ratio
e		= 0.85;			% Oswald's efficiency factor
m		= 5.44;			% Vehicle mass
Nmax	= 2.0;			% Maximum load factor (positive)
Nmin	= 0;			% Minimum load factor (negative)
CL_max	= 1.2;			% Maximum lift coefficient
dphi_dt_max = 30*pi/180;% Maximum roll rate (rad/s)
max_climb = 50*pi/180;	% Maximum air relative climb angle (rad)
GR_approx = 30;			% Approximate glide ratio (for fitness)

% --- Figure setup --- %
h_fig = figure(10); clf; %
set(h_fig, 'Position', [100, 100, 640, 480]);
set(gca, 'Zdir', 'reverse'); set(gca, 'Ydir', 'reverse'); axis equal;
view(3); hold on;
colours = [1 0.6 0.6; 0.6 1 0.6; 0.6 0.6 1; 1 0.6 1; 1 1 0.6; 0.6 1 1];
xlabel('X'); ylabel('Y'); zlabel('Z');

% --- Target flight vector --- %
target_pos = [500; 20; -100]; %[300; 0; -400];
plot3(target_pos(1), target_pos(2), target_pos(3), 'ro', 'Color', ...
	[0.8,0,0], 'MarkerSize', 10, 'LineWidth', 2);

% --- Wind Field --- %
% ----- THERMAL FIELD ----- 
t1 = @(x, y, z) torus_thermal(x, y, z, 5, 50, 2, [50;0;50]);
t2 = @(x, y, z) torus_thermal(x, y, z, 3, 100, 2, [0;300;100]);
gr =  @(x, y, z) pohlhausen(z, 0, 4, -200, 0, 45);
% gr = @(x, y, z) sine_wind(x, y, z, V_sine, 500, 500);
wind_function = @(x, y, z) multi_field(x, y, z, t1, t2, gr);


% --- Fitness functions --- %
% The fitness function is used to rank the end state of each generated
% trajectory. It must return a scalar value for each path segment
fitness_f = @fitness_autobalance;


%% GP OBSERVATION SET
max_obs = 200;
length_scale = 40;
sigma_f = 0.50;
sigma_n = 0.09;
cov_funs = {@square_exp, @d_square_exp};
loghyper = log([length_scale, sigma_f, sigma_n]);


%% INITIALISATION VARIABLES
start_pos = [0; 0;-50];
start_att = [0; 0; 0]*pi/180;
V0 = 15;
plot3(start_pos(1), start_pos(2), start_pos(3), 'g^', 'Color', [0,.5,0], ...
	'MarkerSize', 10, 'LineWidth', 2);

t0 = 0;				% Initial time
tf = 200;			% Final time
lookahead = 1;		% Lookahead horizo
t_plan = 5;			% How long to plan ahead based on current wind estimate
replan = 3;			% How frequently should the plan be recalculated
dt = 0.01;			% Time step
ntf = 3;			% Number of path estimates


%% AUTOMATIC VARIABLES
n_replan = (tf-t0)/replan;		% Total number of replans

E0 = m*g*-start_pos(3) + 0.5*m*V0*V0;

current_pos = start_pos;
current_att = start_att;
current_V = V0;

old_pos = start_pos;
old_att = start_att;
old_V = V0;

%% 

for i = 1:n_replan
	
	%Plan the route using current wind estimate
	
	% Calculate Ki from currrent wind estimate
	Ki = GP_predict(x_obs, y_obs, [], cov_funs{1}, loghyper);
	W_function = @(X_test) deal(GP_predict(X_obs, W_obs, X_test, cov_funs{1}, loghyper, Ki), ...
		dGP_predict(X_obs, W_obs, X_test, [1,2,3], cov_funs{2}, loghyper, Ki));
	
	W_avg = W_current; %2*W_current - W_old;
	Jw_avg = Jw_current; %2*Jw_current - Jw_old;
	
	[full_controls] = calculate_path_segment(current_pos, current_att, ...
		current_V, target_pos, W_avg, Jw_avg, t_plan, lookahead, dt, ntf);
	
	axis equal;
	M((i-1)*2 + 1) = getframe(h_fig, [0, 0, 640, 480]);
	
	% Execute the commands generated by the planner
	[pos_full, att_full, V_full] = wind_sim3_control(current_pos, ...
		current_att, current_V, dt/2, ...
		full_controls(:,1:round(replan/lookahead)), lookahead, ...
		W_handle, ntf);
	plot3(pos_full(1,:), pos_full(2,:), pos_full(3,:), 'k-', 'LineWidth', 2);
	
	M((i-1)*2 + 2) = getframe(h_fig, [0, 0, 640, 480]);
	
	%Replan
	old_pos = current_pos;
	old_att = current_att;
	old_V = current_V;
	
	current_pos = pos_full(:,end);
	current_att = att_full(:,end);
	current_V = V_full(end);
end

%%
axis equal;

XX = get(gca, 'XLim'); XX = linspace(XX(1), XX(2), 7);
YY = get(gca, 'YLim'); YY = linspace(YY(1), YY(2), 7);
ZZ = get(gca, 'ZLim'); ZZ = linspace(ZZ(1), ZZ(2), 7);

h_quiver = zeros(3,1);
for i = 1:3
	switch i
		case 1
			[X1, Y1, Z1] = meshgrid(XX, YY, ZZ(end));
		case 2
			[X1, Y1, Z1] = meshgrid(XX(end), YY, ZZ);
		case 3
			[X1, Y1, Z1] = meshgrid(XX, YY(1), ZZ);
	end
	
	V_w = W_handle([X1(:)'; Y1(:)'; Z1(:)']);
	U_wind = reshape(V_w(1,:), size(X1))*~(X1(1)==X1(end));
	V_wind = reshape(V_w(2,:), size(X1))*~(Y1(1)==Y1(end));
	W_wind = reshape(V_w(3,:), size(X1))*~(Z1(1)==Z1(end));
	h_quiver(i) = quiver3(X1, Y1, Z1, U_wind, V_wind, W_wind, 0.2, ...
		'Color', [40 183 183]/255);
end

view(3);
M(numel(M)+1) = getframe(h_fig, [0, 0, 640, 480]);